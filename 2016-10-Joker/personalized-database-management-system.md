# СУБД: Индивидуальный подшив и подгон по фигуре
[Филипп Дельгядо @ Joker 2016](https://www.youtube.com/watch?v=l4l5pLlC40U)

1) PGQueue: стандартный постгрес можно юзать для очереди (1000 операций в секунду).
* Вложенные транзакции реализуются за счет спринга.
* Надежность и прочее легко реализуется за счет самих queue-табличек постгреса.
* В базе события храним как текст, т.к. (де-)сериализация - ответственность бизнес-логики, только она знает точный состав данных
* PGQueue устарела после появления skip locked. Это решение, когда нужна была очередь с транзакциями в БД. Со skip locked это сделать на порядки проще.
* PGQueue больше заточена на пакетную обработку: взять на аппликейшн слое пачку событий и загрузить. А вот re-delivery придется писать самому.
* Создание новой очереди - дешевая операция (тупо инсёрт), таким образом внутри шаги будут последовательно обрабатываться, но можно параллельно обрабатывать много документов.

У Дельгядо каждый платеж обрабатывается в своей отдельной новой очереди. Десятки тыщ очередей - это нормально и успешно тестировалось.
Логика миграции на аппликейшн слое, т.к ALTER TABLE с добавлением даже пустого столбца можно залочить надолго таблицу на проде. Плюс на аппликейшн-слое проще писать сложную логику миграции.

2) OTP-базы (основные ключи в полях + вся остальная инфа в jsonb) - is the new black.
* Рекомендуется хранить еще и поле с номером схемы (для облегчения дальнейшей миграции.
* сложно делать репорты, но для этого есть отдельные инструменты
* Рекомендуется заранее написать скрипт миграции на новую схему, чтобы потом по кусочкам можно было прогонять (в том числе на проде при откате очередного релиза)
* Рекомендуется выбирать весь объект по ключу и сериализовать объект, т.к. физический read всё равно один.
  Для базы знать, что у нас data->amount->>value - плохо
* При сериализации Jackson'ом достаточно юзать только приватные поля (без сеттеров), во время до-сериализации он сам заполнит только пустые поля.
  Умеет фильтровать, какие атрибуты сериализовать - @JsonView(DB.class) (статья на хабре - https://habrahabr.ru/post/307392/)
  Умеет полиморфизм -  JsonTypeInfo usage
* JsonAnySetter понимает сразу 2 или 3 версии объекта и нормально раскладывает (через делегацию кастомному коду, если не понял, как сериализовать поле/объект)

```java
class Operations {
  static final int SCHEMA = 1
  private long id;
  private long userId;
  private String state;
  @JsonView(DB.class) private Money amount;
  @JsonView(DB.class) private List<Params> params;

  public Operations(id, userId, state) {...}
}

jdbc().query(
"select id, userId, state, data
   from operations where userId = ?", uid,
(rs, i) ->
{
	Operations operation;
	operation = new Operations
		(rs.getLong(1),
		 rs.getLong(2),
		 rs.getString(3));
	objectMapper
    .readyForUpdating(operation)
    .readValue(rs.getString(4));
});
```

3) Бонусы использования схемы с json'ами
* Оптимистическая блокировка (просто добавляется поле версии)
* Легко хранить историю изменений (тупо инсёрт вместо апдейта в отдельную табличку)
* Криптозащита (постгрес не умеет шифровать по госту, но типа 5 строчек, используя расширение, положат шифрованный объект в базу и никакой DBA данные не прочтет)

4) Том Кайт "Оракл для профессионалов" - первые 200 страниц достаточно.

5) Про отчеты - выгружаются все данные в business intelligence и дальше аналитики делают что им надо
